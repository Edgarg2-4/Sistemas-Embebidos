///*** PROGRAMA QUE CONFIGURA EL PERIFERICO I2C ***
//*** EN EL TIVA TM4C1294 COMO MAESTRO Y ESCLAVO EL RTC DS1307***

//Librerias
#include<stdint.h>
#include<stdbool.h>

//REGISTROS DE RELOJ
#define SYSCTL_RCGCGPIO_R       (*((volatile uint32_t *)0x400FE608)) //Reloj del puerto
#define SYSCTL_RCGCI2C_R        (*((volatile uint32_t *)0x400FE620)) //Reloj de I2C
#define SYSCTL_PRGPIO_R        (*((volatile uint32_t *)0x400FEA08)) //Bandera de "Peripherial Ready"

//REGISTROS DEL PUERTO B
#define GPIO_PORTB_DATA_R   (*((volatile uint32_t *)0x400593FC)) //Para los datos del puerto
#define GPIO_PORTB_DIR_R    (*((volatile uint32_t *)0x40059400)) //Para seleccionar función
#define GPIO_PORTB_AFSEL_R  (*((volatile uint32_t *)0x40059420)) //Para seleccionar función alterna
#define GPIO_PORTB_ODR_R    (*((volatile uint32_t *)0x4005950C)) //Para activar el Open Drain
#define GPIO_PORTB_DEN_R    (*((volatile uint32_t *)0x4005951C)) //Para activar función digital
#define GPIO_PORTB_PCTL_R   (*((volatile uint32_t *)0x4005952C)) //Para el control del puerto

//REGISTROS DEL MÓUDLO I2C
#define I2C0_MSA_R              (*((volatile uint32_t *)0x40020000)) //I2C Master Slave Adress
#define I2C0_MCS_R              (*((volatile uint32_t *)0x40020004)) //I2C Master Control Status
#define I2C0_MDR_R              (*((volatile uint32_t *)0x40020008)) //I2C Master Data Register
#define I2C0_MTPR_R             (*((volatile uint32_t *)0x4002000C)) //I2C Master Time Period
#define I2C0_MCR_R              (*((volatile uint32_t *)0x40020020)) //I2C Master Configuration Register
#define I2C0_MICR_R              (*((volatile uint32_t *)0x4002001C)) //I2C Master Configuration Register
#define I2C0_MIMR_R              (*((volatile uint32_t *)0x40020010))
#define I2C0_EN0_R              (*((volatile uint32_t *)0xE000E100))


/*
El registro I2C Master Control/Status (I2C_MCS_R) tiene:
-Modo READ-ONLY DATUS: los 7 bits menos significativos son:
    7:Clock Time Out Error  6:BUS BUSY      5:IDLE
    4:Arbitration Lost      3:DataAck       2:AdrAck
    1:Error                 0:CONTROLLER BUSY

-Modo WRITE-ONLY CONTROL_ Los 6 bits menos significativos son:
    6:BURST    5:QuickCommand  4:High Speed Enable
    3:ACK      2:STOP          1:START
    0:RUN
*/
#define I2C_MCS_ACK 0x00000008 //Transmmitter Acknowledge Enable
#define I2C_MCS_DATACK 0x00000008 // Data Acknowledge Enable
#define I2C_MCS_ADRACK 0x00000004 // Acknowledge Address
#define I2C_MCS_STOP 0x00000004 // Generate STOP
#define I2C_MCS_START 0x00000002 // Generate START
#define I2C_MCS_ERROR 0x00000002 // Error
#define I2C_MCS_RUN 0x00000001 // I2C Master Enable

//**Direcciones del VL53l0x
int Adrevl5301 =0x029;///Dirección del RTC DS1307
int SYSRANGE_START=0x00;
int SYSTEM_THRESH_HIGH=0x0C; // umbral de interrupcion
int SYSTEM_THRESH_LOW=0x0E;
int SYSTEM_SEQUENCE_CONFIG=0x01;
int SYSTEM_RANGE_CONFIG=0x09;
int SYSTEM_INTERMEASUREMENT_PERIOD=0x04;
int SYSTEM_INTERRUPT_CONFIG_GPIO=0x0A;
int GPIO_HV_MUX_ACTIVE_HIGH=0x84;
int SYSTEM_INTERRUPT_CLEAR=0x0B;

int RESULT_INTERRUPT_STATUS=0x13;
int RESULT_RANGE_STATUS=0x14;
int RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN=0xBC;
int RESULT_CORE_RANGING_TOTAL_EVENTS_RTN=0xC0;
int RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF=0xD0;
int RESULT_CORE_RANGING_TOTAL_EVENTS_REF=0xD4;
int RESULT_PEAK_SIGNAL_RATE_REF=0xB6;

int ALGO_PART_TO_PART_RANGE_OFFSET_MM=0x28;
int I2C_SLAVE_DEVICE_ADDRESS=0x8A;
int MSRC_CONFIG_CONTROL=0x60;
int PRE_RANGE_CONFIG_MIN_SNR=0x27;
int PRE_RANGE_CONFIG_VALID_PHASE_LOW=0x56;
int PRE_RANGE_CONFIG_VALID_PHASE_HIGH=0x57;
int PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT=0x64;

int FINAL_RANGE_CONFIG_MIN_SNR=0x67;
int FINAL_RANGE_CONFIG_VALID_PHASE_LOW=0x47;
int FINAL_RANGE_CONFIG_VALID_PHASE_HIGH=0x48;
int FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT=0x44;

int PRE_RANGE_CONFIG_SIGMA_THRESH_HI=0x61;
int PRE_RANGE_CONFIG_SIGMA_THRESH_LO=0x62;

int PRE_RANGE_CONFIG_VCSEL_PERIOD=0x50;
int PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI=0x51;
int PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO=0x52;

int SYSTEM_HISTOGRAM_BIN=0x81;
int HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT=0x33;
int HISTOGRAM_CONFIG_READOUT_CTRL=0x55;

int FINAL_RANGE_CONFIG_VCSEL_PERIOD=0x70;
int FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI=0x71;
int FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO =0x72;
int CROSSTALK_COMPENSATION_PEAK_RATE_MCPS =0x20;

int MSRC_CONFIG_TIMEOUT_MACROP=0x46;

int SOFT_RESET_GO2_SOFT_RESET_N=0xBF;
int IDENTIFICATION_MODEL_ID=0xC0;
int IDENTIFICATION_REVISION_ID=0xC2;

int OSC_CALIBRATE_VAL=0xF8;

int GLOBAL_CONFIG_VCSEL_WIDTH=0x32;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_0=0xB0;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_1=0xB1;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_2=0xB2;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_3=0xB3;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_4=0xB4;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_5=0xB5;

int GLOBAL_CONFIG_REF_EN_START_SELECT=0xB6;
int DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD=0x4E;
int DYNAMIC_SPAD_REF_EN_START_OFFSET=0x4F;
int POWER_MANAGEMENT_GO1_POWER_FORCE=0x80;

int VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV=0x89;

int ALGO_PHASECAL_LIM=0x30;
int ALGO_PHASECAL_CONFIG_TIMEOUT=0x30;

/*El cálculo del Time Period Register (TPR) se especifica en la página 1284
 Asumiendo un reloj de 16 MHz y un modo de operación estándar (100 kbps):
*/
int TPR = 7;

// Variables para manejar los valores del RTC

uint8_t error;
int status:
uint32_t i;
int cont=1;
uint16_t dataH, datal;
unint32_t valor;

//*** Función que inicializa los relojes, el GPIO y el I2C0 ***
void I2C_Init(void){
    //CONFIGURACIÓN DE LOS RELOJ
    SYSCTL_RCGCI2C_R |= 0x0001; // Activamos el reloj de I2C0 [I2C9 I2C8 I2C7 ... I2C0]<--Mapa de RCGCI2C
    SYSCTL_RCGCGPIO_R |= 0x0002; // Activamos el reloj GPIO_PORTB mientras se activa el reloj de I2C0
    while((SYSCTL_PRGPIO_R&0x0002) == 0){};//Espero a que se active el reloj del puerto B

    //CONFIGURACIÓN DE LOS GPIOS
    /*Acorde con la tabla "Signals by function" de la p. 1808:
     el PIN 2 del puerto B (PB2) es el I2C0SCL del I2C0, y
     el PIN 3 del puerto B (PB3) es el I2C0SDA del I2C0
    */
    GPIO_PORTB_AFSEL_R |= 0x0C; // Activo la función alterna del PB2 y PB3
    GPIO_PORTB_ODR_R |= 0x08;   // Activo el OPEN DRAIN para el PB3, ya que el PB2 ya tiene uno por preconfig.
    GPIO_PORTB_DIR_R |= 0x0C;   //Activo al PB2 y al PB3 como OUTPUT
    GPIO_PORTB_DEN_R |= 0x0C;   //Activo la función digital de PB3 y PB2
    /*
    Así como el registro AFSEL indica que se ejecutará una función externa, en el registro PCTL
    debemos indicar qué función alterna se realizará acorde con la tabla 26-5 de la p.1808 e indicarlo
     en el correspondiente PCMn (uno por cada bit del puerto) del registro PCTL
     */
    GPIO_PORTB_PCTL_R|=0x00002200;

    //CONFIGURACIÓN DEL MODULO I2C0
    I2C0_MCR_R = 0x00000010; // Habilitar función MASTER para el I2C0
    I2C0_MTPR_R = TPR; // Se establece una velocidad estándar de 100kbps

//    I2C0_MICR_R=0x00000001; //clear
//
//    I2C0_MIMR_R=0x00000001; //habilitacion de interrupcion
//
//    I2C0_EN0_R = 0x100;


}


// ** Función esperar **
int esperar(){
    while(I2C0_MCS_R&0x00000001){}; //Espero a que la transmisión acabe
      if(I2C0_MCS_R&0x00000002==1){ //¿Hubo error?
          error=1;
          return error;
      };
      return 0;

}


//** Función para configurar al esclavo Vl53l01 **

void writevl5301(int registro, int valor){




    //Para transmitir
    I2C0_MSA_R=(Adrevl5301<<1)&0xFE; //Cargo la dirección del DS1307 e indico "SEND", es decir, el Slave va a recibir
    I2C0_MDR_R=regsitro &0x0FF; //Envio la Subdirección( dirección del registro interno "segundos") al DS1307
    I2C0_MCS_R=(I2C_MCS_RUN|I2C_MCS_START); // Condición de START y corro


        I2C0_MDR_R= valor; //Envio el valor.
        I2C0_MCS_R=(I2C_MCS_STOP|I2C_MCS_RUN); //Inicio la ultima transmisión y STOP
        for(i=0;i<150;i++){} //Delay
        esperar();

}

void readvl5301(int reg, int lectura){
        while(I2C0_MCS_R&0x00000001){}; // wait for I2C ready

        //Para actualizar registro para iniciar la lectura
        I2C0_MSA_R=(AdreDS1307<<1)&0xFE; //Cargo la dirección del DS1207 e indico "SEND", es decir, el Slave va a recibir
        I2C0_MDR_R=reg&0x0FF; //Envio la Subdirección( dirección del registro interno "segundos") al DS1307
        I2C0_MCS_R=(I2C_MCS_START|I2C_MCS_RUN);// Condición de START, y corro
        for(i=0;i<150;i++){} //Delay
        esperar();
        lectura =(I2C0_MDR_R&0xFF); //El Master lee lo que envía el DS1307

        I2C0_MCS_R=(I2C_MCS_STOP|I2C_MCS_RUN); //corro, alto


}

void configvl53l0x(void){
    //Establecer el modo estandar de I2C
    writevl5301(VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV, 0x89|0x01); // falta leer antes
    writevl5301(0x88, 0x00);
    writevl5301(POWER_MANAGEMENT_GO1_POWER_FORCE, 0x01);
    writevl5301(0xFF, 0x01);
    writevl5301(SYSRANGE_START, 0x00);
    writevl5301(SYSRANGE_START, 0x01);
    writevl5301(0xFF, 0x00);
    writevl5301(POWER_MANAGEMENT_GO1_POWER_FORCE, 0x00);
    //deshabilite las comprobaciones del limete signal_rate_msrc
    writevl5301(MSRC_CONFIG_CONTROL, 0x12); // falta leer registro
    writevl5301(SYSTEM_SEQUENCE_CONFIG, 0xFF);
    //Configuracion de SPADS
    writevl5301(0xFF, 0x01);// funciona para cambiar la hoja de registros
    writevl5301(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
    writevl5301(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C); // 44 Spads leida en memoria de fabrica del sensor
    writevl5301(0xFF, 0x00);
    //Configuracion normal
    writevl5301(GLOBAL_CONFIG_REF_EN_START_SELEC, 0xB4); //indice de matriz SPADs
    //encontrar funcion de spads de apertura

    //carga de tuning_settings
    writevl5301(0xFF, 0x01);
    writevl5301(SYSRANGE_START, 0x00);
// registros que controlan configuraciones internas de disparo y control automatico
            writevl5301(0xFF, 0x00);
            writevl5301(SYSTEM_RANGE_CONFIG, 0x00);
            writevl5301(0x10, 0x00);
            writevl5301(0x11, 0x00);
// registros de rangos maximos, control de SPADs y respuesta del lase
            writevl5301(0x24, 0x01);
            writevl5301(0x25, 0xFF);
            writevl5301(0x75, 0x00);
// Configura numero de SPADs de referencia
            writevl5301(0xFF, 0x01);
            writevl5301(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
            writevl5301(FINAL_RANGE_CONFIG_VALID_PHASE_HIGH, 0x00);
            writevl5301(ALGO_PHASECAL_LIM, 0x20);
// parametros del sistema de medicion, se configura timings ganancias, sensibilidad y comportamiento del sistema optico
            writevl5301(0xFF, 0x00);
            writevl5301(ALGO_PHASECAL_LIM, 0x09);
            writevl5301(0x54, 0x00);
            writevl5301(0x31, 0x04);
            writevl5301(GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);
            writevl5301(0x40, 0x83);
            writevl5301(0x46, 0x25);
            writevl5301(0x60, 0x00);
            writevl5301(0x27, 0x00);
            writevl5301(0x50, 0x06);
            writevl5301(0x51, 0x00);
            writevl5301(0x52, 0x96);
            writevl5301(0x56, 0x08);
            writevl5301(0x57, 0x30);
            writevl5301(0x61, 0x00);
            writevl5301(0x62, 0x00);
            writevl5301(0x64, 0x00);
            writevl5301(0x65, 0x00);
            writevl5301(0x66, 0xA0);
//Configuracion de disparo y ROI
            writevl5301(0xFF, 0x01);
            writevl5301(0x22, 0x32);
            writevl5301(0x47, 0x14);
            writevl5301(0x49, 0xFF);
            writevl5301(0x4A, 0x00);
//Ajuste de precisión
            writevl5301(0xFF, 0x00);
            writevl5301(0x7A, 0x0A);
            writevl5301(0x7B, 0x00);
            writevl5301(0x78, 0x21);

            writevl5301(0xFF, 0x01);
            writevl5301(0x23, 0x34);
            writevl5301(0x42, 0x00);
            writevl5301(0x44, 0xFF);
            writevl5301(0x45, 0x26);
            writevl5301(0x46, 0x05);
            writevl5301(0x40, 0x40);
            writevl5301(0x0E, 0x06);
            writevl5301(0x20, 0x1A);
            writevl5301(0x43, 0x40);
//Ajustes de precisión
            writevl5301(0xFF, 0x00);
            writevl5301(0x34, 0x03);
            writevl5301(0x35, 0x44);

            writevl5301(0xFF, 0x01);
            writevl5301(0x31, 0x04);
            writevl5301(0x4B, 0x09);
            writevl5301(0x4C, 0x05);
            writevl5301(0x4D, 0x04);

            writevl5301(0xFF, 0x00);
            writevl5301(0x44, 0x00);
            writevl5301(0x45, 0x20);
            writevl5301(0x47, 0x08);
            writevl5301(0x48, 0x28);
            writevl5301(0x67, 0x00);
            writevl5301(0x70, 0x04);
            writevl5301(0x71, 0x01);
            writevl5301(0x72, 0xFE);
            writevl5301(0x76, 0x00);
            writevl5301(0x77, 0x00);

            writevl5301(0xFF, 0x01);
            writevl5301(0x0D, 0x01);

            writevl5301(0xFF, 0x00);
            writevl5301(0x80, 0x01);
            writevl5301(0x01, 0xF8);

            writevl5301(0xFF, 0x01);
            writevl5301(0x8E, 0x01);
            writevl5301(SYSRANGE_START, 0x01);
            writevl5301(0xFF, 0x00);
            writevl5301(0x80, 0x00);

            // Configuracion de Medicion
            writevl5301(0x00, 0x00);

            // Establecer en modo continuo
            writevl5301(0x80, 0x01);
            writevl5301(0xFF, 0x01);
            writevl5301(0x00, 0x00);
            writevl5301(0x91, stop_variable);  // Guardado desde init (calibración previa)
            writevl5301(0x00, 0x01);
            writevl5301(0xFF, 0x00);
            writevl5301(0x80, 0x00);

            // Iniciar modo continuo
            writevl5301(0x00, 0x02);
}



//*** PROGRAMA PRINCIPAL ****

void main(){

    I2C_Init(); //Función que inicializa los relojes, el GPIO y el I2C0

    //Inicializo Slave
    while(I2C0_MCS_R&0x00000001){}; // espera que el I2C esté listo


    //Para transmitir
for(i=0;i<1000;i++){}

    readvl5301(0xC0, leer);//0xEE
    readvl5301(0xC1, leer);//0xAA
//lectura de datos
    configvl53l0x();

    while(1){
        do {
            readvl5301(0x13,status);
        } while ((status & 0x07) == 0)
        readvl5301(0x1E, dataH;//High byte
          readvl5301(0x1F, datal); // Low byte
          valor=(dataH<<16)|datal;
          writevl5301(0x0B, 0x01);

    }


}
