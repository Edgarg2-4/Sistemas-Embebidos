///*** PROGRAMA QUE CONFIGURA EL PERIFERICO I2C ***
//*** EN EL TIVA TM4C1294 COMO MAESTRO Y ESCLAVO EL RTC DS1307***

//Librerias
#include<stdint.h>
#include<stdbool.h>

//REGISTROS DE RELOJ
#define SYSCTL_RCGCGPIO_R       (*((volatile uint32_t *)0x400FE608)) //Reloj del puerto
#define SYSCTL_RCGCI2C_R        (*((volatile uint32_t *)0x400FE620)) //Reloj de I2C
#define SYSCTL_PRGPIO_R        (*((volatile uint32_t *)0x400FEA08)) //Bandera de "Peripherial Ready"

//REGISTROS DEL PUERTO B
#define GPIO_PORTB_DATA_R   (*((volatile uint32_t *)0x400593FC)) //Para los datos del puerto
#define GPIO_PORTB_DIR_R    (*((volatile uint32_t *)0x40059400)) //Para seleccionar función
#define GPIO_PORTB_AFSEL_R  (*((volatile uint32_t *)0x40059420)) //Para seleccionar función alterna
#define GPIO_PORTB_ODR_R    (*((volatile uint32_t *)0x4005950C)) //Para activar el Open Drain
#define GPIO_PORTB_DEN_R    (*((volatile uint32_t *)0x4005951C)) //Para activar función digital
#define GPIO_PORTB_PCTL_R   (*((volatile uint32_t *)0x4005952C)) //Para el control del puerto

//REGISTROS DEL MÓUDLO I2C
#define I2C0_MSA_R              (*((volatile uint32_t *)0x40020000)) //I2C Master Slave Adress
#define I2C0_MCS_R              (*((volatile uint32_t *)0x40020004)) //I2C Master Control Status
#define I2C0_MDR_R              (*((volatile uint32_t *)0x40020008)) //I2C Master Data Register
#define I2C0_MTPR_R             (*((volatile uint32_t *)0x4002000C)) //I2C Master Time Period
#define I2C0_MCR_R              (*((volatile uint32_t *)0x40020020)) //I2C Master Configuration Register
#define I2C0_MICR_R              (*((volatile uint32_t *)0x4002001C)) //I2C Master Configuration Register
#define I2C0_MIMR_R              (*((volatile uint32_t *)0x40020010))
#define I2C0_EN0_R              (*((volatile uint32_t *)0xE000E100))


/*
El registro I2C Master Control/Status (I2C_MCS_R) tiene:
-Modo READ-ONLY DATUS: los 7 bits menos significativos son:
    7:Clock Time Out Error  6:BUS BUSY      5:IDLE
    4:Arbitration Lost      3:DataAck       2:AdrAck
    1:Error                 0:CONTROLLER BUSY

-Modo WRITE-ONLY CONTROL_ Los 6 bits menos significativos son:
    6:BURST    5:QuickCommand  4:High Speed Enable
    3:ACK      2:STOP          1:START
    0:RUN
*/
#define I2C_MCS_ACK 0x00000008 //Transmmitter Acknowledge Enable
#define I2C_MCS_DATACK 0x00000008 // Data Acknowledge Enable
#define I2C_MCS_ADRACK 0x00000004 // Acknowledge Address
#define I2C_MCS_STOP 0x00000004 // Generate STOP
#define I2C_MCS_START 0x00000002 // Generate START
#define I2C_MCS_ERROR 0x00000002 // Error
#define I2C_MCS_RUN 0x00000001 // I2C Master Enable

//**Direcciones del VL53l0x
int Adrevl5301 =0x029;///Dirección del RTC DS1307
int SYSRANGE_START=0x00;
int SYSTEM_THRESH_HIGH=0x0C;
int SYSTEM_THRESH_LOW=0x0E;
int SYSTEM_SEQUENCE_CONFIG=0x01;
int SYSTEM_RANGE_CONFIG=0x09;
int SYSTEM_INTERMEASUREMENT_PERIOD=0x04;
int SYSTEM_INTERRUPT_CONFIG_GPIO=0x0A;
int GPIO_HV_MUX_ACTIVE_HIGH=0x84;
int SYSTEM_INTERRUPT_CLEAR=0x0B;

int RESULT_INTERRUPT_STATUS=0x13;
int RESULT_RANGE_STATUS=0x14;
int RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN=0xBC;
int RESULT_CORE_RANGING_TOTAL_EVENTS_RTN=0xC0;
int RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF=0xD0;
int RESULT_CORE_RANGING_TOTAL_EVENTS_REF=0xD4;
int RESULT_PEAK_SIGNAL_RATE_REF=0xB6;

int ALGO_PART_TO_PART_RANGE_OFFSET_MM=0x28;
int I2C_SLAVE_DEVICE_ADDRESS=0x8A;
int MSRC_CONFIG_CONTROL=0x60;
int PRE_RANGE_CONFIG_MIN_SNR=0x27;
int PRE_RANGE_CONFIG_VALID_PHASE_LOW=0x56;
int PRE_RANGE_CONFIG_VALID_PHASE_HIGH=0x57;
int PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT=0x64;

int FINAL_RANGE_CONFIG_MIN_SNR=0x67;
int FINAL_RANGE_CONFIG_VALID_PHASE_LOW=0x47;
int FINAL_RANGE_CONFIG_VALID_PHASE_HIGH=0x48;
int FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT=0x44;

int PRE_RANGE_CONFIG_SIGMA_THRESH_HI=0x61;
int PRE_RANGE_CONFIG_SIGMA_THRESH_LO=0x62;

int PRE_RANGE_CONFIG_VCSEL_PERIOD=0x50;
int PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI=0x51;
int PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO=0x52;

int SYSTEM_HISTOGRAM_BIN=0x81;
int HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT=0x33;
int HISTOGRAM_CONFIG_READOUT_CTRL=0x55;

int FINAL_RANGE_CONFIG_VCSEL_PERIOD=0x70;
int FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI=0x71;
int FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO =0x72;
int CROSSTALK_COMPENSATION_PEAK_RATE_MCPS =0x20;

int MSRC_CONFIG_TIMEOUT_MACROP=0x46;

int SOFT_RESET_GO2_SOFT_RESET_N=0xBF;
int IDENTIFICATION_MODEL_ID=0xC0;
int IDENTIFICATION_REVISION_ID=0xC2;

int OSC_CALIBRATE_VAL=0xF8;

int GLOBAL_CONFIG_VCSEL_WIDTH=0x32;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_0=0xB0;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_1=0xB1;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_2=0xB2;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_3=0xB3;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_4=0xB4;
int GLOBAL_CONFIG_SPAD_ENABLES_REF_5=0xB5;

int GLOBAL_CONFIG_REF_EN_START_SELEC=0xB6;
int DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD=0x4E;
int DYNAMIC_SPAD_REF_EN_START_OFFSET=0x4F;
int POWER_MANAGEMENT_GO1_POWER_FORCE=0x80;

int VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV=0x89;

int ALGO_PHASECAL_LIM=0x30;
int ALGO_PHASECAL_CONFIG_TIMEOUT=0x30;

/*El cálculo del Time Period Register (TPR) se especifica en la página 1284
 Asumiendo un reloj de 16 MHz y un modo de operación estándar (100 kbps):
*/
int TPR = 7;

// Variables para manejar los valores del RTC
int segundos=0x00, minutos=0x59, horas=0x23, dia=0x07, fecha=0x31, mes=0x12, anio=0x25;
uint8_t error;
uint32_t i;
int cont=1;

//*** Función que inicializa los relojes, el GPIO y el I2C0 ***
void I2C_Init(void){
    //CONFIGURACIÓN DE LOS RELOJ
    SYSCTL_RCGCI2C_R |= 0x0001; // Activamos el reloj de I2C0 [I2C9 I2C8 I2C7 ... I2C0]<--Mapa de RCGCI2C
    SYSCTL_RCGCGPIO_R |= 0x0002; // Activamos el reloj GPIO_PORTB mientras se activa el reloj de I2C0
    while((SYSCTL_PRGPIO_R&0x0002) == 0){};//Espero a que se active el reloj del puerto B

    //CONFIGURACIÓN DE LOS GPIOS
    /*Acorde con la tabla "Signals by function" de la p. 1808:
     el PIN 2 del puerto B (PB2) es el I2C0SCL del I2C0, y
     el PIN 3 del puerto B (PB3) es el I2C0SDA del I2C0
    */
    GPIO_PORTB_AFSEL_R |= 0x0C; // Activo la función alterna del PB2 y PB3
    GPIO_PORTB_ODR_R |= 0x08;   // Activo el OPEN DRAIN para el PB3, ya que el PB2 ya tiene uno por preconfig.
    GPIO_PORTB_DIR_R |= 0x0C;   //Activo al PB2 y al PB3 como OUTPUT
    GPIO_PORTB_DEN_R |= 0x0C;   //Activo la función digital de PB3 y PB2
    /*
    Así como el registro AFSEL indica que se ejecutará una función externa, en el registro PCTL
    debemos indicar qué función alterna se realizará acorde con la tabla 26-5 de la p.1808 e indicarlo
     en el correspondiente PCMn (uno por cada bit del puerto) del registro PCTL
     */
    GPIO_PORTB_PCTL_R|=0x00002200;

    //CONFIGURACIÓN DEL MODULO I2C0
    I2C0_MCR_R = 0x00000010; // Habilitar función MASTER para el I2C0
    I2C0_MTPR_R = TPR; // Se establece una velocidad estándar de 100kbps

//    I2C0_MICR_R=0x00000001; //clear
//
//    I2C0_MIMR_R=0x00000001; //habilitacion de interrupcion
//
//    I2C0_EN0_R = 0x100;


}


// ** Función esperar **
int esperar(){
    while(I2C0_MCS_R&0x00000001){}; //Espero a que la transmisión acabe
      if(I2C0_MCS_R&0x00000002==1){ //¿Hubo error?
          error=1;
          return error;
      };
      return 0;

}


//** Función para configurar al esclavo Vl53l01 **

void writevl5301(int registro, int valor){




    //Para transmitir
    I2C0_MSA_R=(Adrevl5301<<1)&0xFE; //Cargo la dirección del DS1307 e indico "SEND", es decir, el Slave va a recibir
    I2C0_MDR_R=regsitro &0x0FF; //Envio la Subdirección( dirección del registro interno "segundos") al DS1307
    I2C0_MCS_R=(I2C_MCS_RUN|I2C_MCS_START); // Condición de START y corro


        I2C0_MDR_R= valor; //Envio el valor.
        I2C0_MCS_R=(I2C_MCS_STOP|I2C_MCS_RUN); //Inicio la ultima transmisión y STOP
        for(i=0;i<150;i++){} //Delay
        esperar();

}

void readvl5301(int reg, int lectura){
        while(I2C0_MCS_R&0x00000001){}; // wait for I2C ready

        //Para actualizar registro para iniciar la lectura
        I2C0_MSA_R=(AdreDS1307<<1)&0xFE; //Cargo la dirección del DS1207 e indico "SEND", es decir, el Slave va a recibir
        I2C0_MDR_R=reg&0x0FF; //Envio la Subdirección( dirección del registro interno "segundos") al DS1307
        I2C0_MCS_R=(I2C_MCS_START|I2C_MCS_RUN);// Condición de START, y corro
        for(i=0;i<150;i++){} //Delay
        esperar();
        lectura =(I2C0_MDR_R&0xFF); //El Master lee lo que envía el DS1307

        I2C0_MCS_R=(I2C_MCS_STOP|I2C_MCS_RUN); //corro, alto


}

void configvl53l0x(void){
    writevl5301(VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV, 0x89);

}

//*** PROGRAMA PRINCIPAL ****

void main(){

    I2C_Init(); //Función que inicializa los relojes, el GPIO y el I2C0

    //Inicializo Slave
    while(I2C0_MCS_R&0x00000001){}; // espera que el I2C esté listo


    //Para transmitir

    CargarFecha(); // Función para configurar al esclavo RTC DS1307


    do{

    }while(error!=1);



}
